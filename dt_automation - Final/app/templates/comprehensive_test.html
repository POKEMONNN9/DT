<!DOCTYPE html>
<html>
<head>
    <title>Comprehensive Filter Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .parameter-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .parameter-name { font-weight: bold; color: #333; margin-bottom: 10px; }
        .values-list { margin: 10px 0; }
        .value-item { 
            display: inline-block; 
            margin: 2px; 
            padding: 4px 8px; 
            background: #f0f0f0; 
            border-radius: 3px; 
            font-size: 12px;
        }
        .test-section { margin: 20px 0; padding: 15px; background: #f9f9f9; border-radius: 5px; }
        .test-form { margin: 10px 0; }
        .test-form select, .test-form input { margin: 5px; padding: 5px; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 3px; }
        .pass { background-color: #d4edda; color: #155724; }
        .fail { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
        button { margin: 5px; padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .operator-info { font-size: 12px; color: #666; margin-left: 10px; }
    </style>
</head>
<body>
    <h1>Comprehensive Filter Test</h1>
    
    <div class="test-section">
        <h2>Available Parameters and Values</h2>
        <div id="parameters-list"></div>
    </div>
    
    <div class="test-section">
        <h2>Quick Filter Test</h2>
        <div class="test-form">
            <label>Parameter:</label>
            <select id="test-param">
                <option value="">Select parameter...</option>
            </select>
            
            <label>Operator:</label>
            <select id="test-operator">
                <option value="equals">equals</option>
                <option value="not_equals">not equals</option>
                <option value="contains">contains</option>
                <option value="not_contains">not contains</option>
                <option value="greater_than">greater than</option>
                <option value="less_than">less than</option>
                <option value="starts_with">starts with</option>
                <option value="ends_with">ends with</option>
                <option value="regex">regex</option>
            </select>
            
            <label>Value:</label>
            <input type="text" id="test-value" placeholder="Enter test value">
            
            <button onclick="runQuickTest()">Test Filter</button>
        </div>
        <div id="quick-test-result"></div>
    </div>
    
    <div class="test-section">
        <h2>Predefined Test Cases</h2>
        <button onclick="runAllPredefinedTests()">Run All Predefined Tests</button>
        <div id="predefined-test-results"></div>
    </div>

    <script>
        // Load findings data
        window.findingsData = {{ findings|tojson }};
        
        // Parameter definitions
        const parameters = {
            'status': { type: 'string', values: [] },
            'domain_name': { type: 'string', values: [] },
            'risk_score': { type: 'numeric', values: [] },
            'ip_asn': { type: 'numeric', values: [] },
            'response_code': { type: 'numeric', values: [] },
            'is_active': { type: 'boolean', values: [] },
            'asrm_triggered': { type: 'boolean', values: [] },
            'pl_submission': { type: 'boolean', values: [] },
            'tags': { type: 'array', values: [] },
            'name_servers_data': { type: 'complex_array', values: [] },
            'mail_servers_data': { type: 'complex_array', values: [] },
            'admin_contact.country': { type: 'string', values: [] },
            'registrant_contact.country': { type: 'string', values: [] },
            'admin_contact.org': { type: 'string', values: [] },
            'registrant_contact.org': { type: 'string', values: [] },
            'registrar': { type: 'string', values: [] },
            'ip_country': { type: 'string', values: [] },
            'discovered_at': { type: 'date', values: [] },
            'first_seen': { type: 'date', values: [] },
            'create_date': { type: 'date', values: [] },
            'expiration_date': { type: 'date', values: [] },
            'server_type': { type: 'string', values: [] },
            'website_title': { type: 'string', values: [] },
            'asrm_rule_applied': { type: 'string', values: [] },
            'phishlabs_case_number': { type: 'string', values: [] },
            'threat_profile.phishing.score': { type: 'numeric', values: [] },
            'threat_profile.malware.score': { type: 'numeric', values: [] },
            'threat_profile.spam.score': { type: 'numeric', values: [] }
        };
        
        function extractValues() {
            const findings = window.findingsData || [];
            
            findings.forEach(finding => {
                for (const [param, config] of Object.entries(parameters)) {
                    if (config.type === 'complex_array') {
                        if (finding[param] && Array.isArray(finding[param])) {
                            finding[param].forEach(item => {
                                if (typeof item === 'object' && item !== null) {
                                    Object.values(item).forEach(value => {
                                        if (typeof value === 'string' && value.trim()) {
                                            config.values.add(value);
                                        }
                                    });
                                }
                            });
                        }
                    } else if (config.type === 'array') {
                        if (finding[param] && Array.isArray(finding[param])) {
                            finding[param].forEach(value => {
                                if (typeof value === 'string' && value.trim()) {
                                    config.values.add(value);
                                }
                            });
                        }
                    } else if (param.includes('.')) {
                        // Handle nested fields
                        const keys = param.split('.');
                        let nestedValue = finding;
                        for (const key of keys) {
                            if (nestedValue && typeof nestedValue === 'object' && key in nestedValue) {
                                nestedValue = nestedValue[key];
                            } else {
                                nestedValue = null;
                                break;
                            }
                        }
                        if (nestedValue !== null && nestedValue !== undefined) {
                            config.values.add(String(nestedValue));
                        }
                    } else {
                        // Handle simple fields
                        if (finding[param] !== null && finding[param] !== undefined) {
                            config.values.add(String(finding[param]));
                        }
                    }
                }
            });
            
            // Convert sets to sorted arrays
            for (const config of Object.values(parameters)) {
                config.values = Array.from(config.values).sort();
            }
        }
        
        function displayParameters() {
            const container = document.getElementById('parameters-list');
            const paramSelect = document.getElementById('test-param');
            
            let html = '';
            
            for (const [param, config] of Object.entries(parameters)) {
                if (config.values.length === 0) continue;
                
                html += `<div class="parameter-section">
                    <div class="parameter-name">${param} (${config.type})</div>
                    <div class="values-list">
                        ${config.values.slice(0, 20).map(value => `<span class="value-item">${value}</span>`).join('')}
                        ${config.values.length > 20 ? `<span class="value-item">... and ${config.values.length - 20} more</span>` : ''}
                    </div>
                </div>`;
                
                // Add to select
                const option = document.createElement('option');
                option.value = param;
                option.textContent = `${param} (${config.values.length} values)`;
                paramSelect.appendChild(option);
            }
            
            container.innerHTML = html;
        }
        
        function evaluateFilter(finding, param, operator, value) {
            // Get the value from the finding
            let findingValue = null;
            
            if (param.includes('.')) {
                // Handle nested fields
                const keys = param.split('.');
                let nestedValue = finding;
                for (const key of keys) {
                    if (nestedValue && typeof nestedValue === 'object' && key in nestedValue) {
                        nestedValue = nestedValue[key];
                    } else {
                        nestedValue = null;
                        break;
                    }
                }
                findingValue = nestedValue;
            } else {
                findingValue = finding[param];
            }
            
            if (findingValue === null || findingValue === undefined) {
                return false;
            }
            
            // Convert values based on type
            const config = parameters[param];
            let convertedFindingValue = findingValue;
            let convertedFilterValue = value;
            
            if (config.type === 'numeric') {
                convertedFindingValue = Number(findingValue);
                convertedFilterValue = Number(value);
            } else if (config.type === 'boolean') {
                convertedFindingValue = findingValue === true || findingValue === 'true' || findingValue === 'True' || findingValue === '1';
                convertedFilterValue = value === 'true' || value === 'True' || value === '1' || value === true;
            } else if (config.type === 'array') {
                if (Array.isArray(findingValue)) {
                    convertedFindingValue = findingValue;
                } else {
                    convertedFindingValue = [];
                }
                convertedFilterValue = value;
            } else if (config.type === 'complex_array') {
                if (Array.isArray(findingValue)) {
                    convertedFindingValue = findingValue;
                } else {
                    convertedFindingValue = [];
                }
                convertedFilterValue = value;
            } else {
                convertedFindingValue = String(findingValue).toLowerCase();
                convertedFilterValue = String(value).toLowerCase();
            }
            
            // Apply operator
            switch (operator) {
                case 'equals':
                    if (config.type === 'array') {
                        return convertedFindingValue.includes(convertedFilterValue);
                    } else if (config.type === 'complex_array') {
                        return convertedFindingValue.some(server => {
                            return Object.values(server).some(prop => 
                                String(prop).toLowerCase() === convertedFilterValue.toLowerCase()
                            );
                        });
                    }
                    return convertedFindingValue === convertedFilterValue;
                case 'not_equals':
                    if (config.type === 'array') {
                        return !convertedFindingValue.includes(convertedFilterValue);
                    } else if (config.type === 'complex_array') {
                        return !convertedFindingValue.some(server => {
                            return Object.values(server).some(prop => 
                                String(prop).toLowerCase() === convertedFilterValue.toLowerCase()
                            );
                        });
                    }
                    return convertedFindingValue !== convertedFilterValue;
                case 'contains':
                    if (config.type === 'array') {
                        return convertedFindingValue.some(item => 
                            String(item).toLowerCase().includes(convertedFilterValue.toLowerCase())
                        );
                    } else if (config.type === 'complex_array') {
                        return convertedFindingValue.some(server => {
                            return Object.values(server).some(prop =>
                                String(prop).toLowerCase().includes(convertedFilterValue.toLowerCase())
                            );
                        });
                    }
                    return convertedFindingValue.includes(convertedFilterValue);
                case 'not_contains':
                    if (config.type === 'array') {
                        return !convertedFindingValue.some(item => 
                            String(item).toLowerCase().includes(convertedFilterValue.toLowerCase())
                        );
                    } else if (config.type === 'complex_array') {
                        return !convertedFindingValue.some(server => {
                            return Object.values(server).some(prop =>
                                String(prop).toLowerCase().includes(convertedFilterValue.toLowerCase())
                            );
                        });
                    }
                    return !convertedFindingValue.includes(convertedFilterValue);
                case 'greater_than':
                    return convertedFindingValue > convertedFilterValue;
                case 'less_than':
                    return convertedFindingValue < convertedFilterValue;
                case 'starts_with':
                    if (config.type === 'complex_array') {
                        return convertedFindingValue.some(server => {
                            return Object.values(server).some(prop => 
                                String(prop).toLowerCase().startsWith(convertedFilterValue.toLowerCase())
                            );
                        });
                    }
                    return convertedFindingValue.startsWith(convertedFilterValue);
                case 'ends_with':
                    if (config.type === 'complex_array') {
                        return convertedFindingValue.some(server => {
                            return Object.values(server).some(prop => 
                                String(prop).toLowerCase().endsWith(convertedFilterValue.toLowerCase())
                            );
                        });
                    }
                    return convertedFindingValue.endsWith(convertedFilterValue);
                case 'regex':
                    try {
                        const regex = new RegExp(convertedFilterValue, 'i');
                        if (config.type === 'complex_array') {
                            return convertedFindingValue.some(server => {
                                return Object.values(server).some(prop =>
                                    regex.test(String(prop))
                                );
                            });
                        }
                        return regex.test(convertedFindingValue);
                    } catch (e) {
                        return false;
                    }
                default:
                    return false;
            }
        }
        
        function runQuickTest() {
            const param = document.getElementById('test-param').value;
            const operator = document.getElementById('test-operator').value;
            const value = document.getElementById('test-value').value;
            
            if (!param || !value) {
                alert('Please select a parameter and enter a value');
                return;
            }
            
            const findings = window.findingsData || [];
            let matches = 0;
            let total = findings.length;
            
            findings.forEach(finding => {
                if (evaluateFilter(finding, param, operator, value)) {
                    matches++;
                }
            });
            
            const resultDiv = document.getElementById('quick-test-result');
            resultDiv.innerHTML = `
                <div class="test-result ${matches > 0 ? 'pass' : 'fail'}">
                    <strong>Filter Test Result:</strong><br>
                    Parameter: ${param}<br>
                    Operator: ${operator}<br>
                    Value: "${value}"<br>
                    Matches: ${matches} out of ${total} findings<br>
                    ${matches > 0 ? '✅ PASS' : '❌ FAIL'}
                </div>
            `;
        }
        
        function runAllPredefinedTests() {
            const container = document.getElementById('predefined-test-results');
            container.innerHTML = '<div class="test-result info">Running predefined tests...</div>';
            
            const tests = [
                { param: 'status', operator: 'equals', value: 'approved', expected: 3 },
                { param: 'risk_score', operator: 'greater_than', value: '50', expected: 5 },
                { param: 'tags', operator: 'contains', value: 'phishing', expected: 2 },
                { param: 'name_servers_data', operator: 'equals', value: 'ns1.cloudflare.com', expected: 1 },
                { param: 'mail_servers_data', operator: 'equals', value: 'mail.legitimate-business.com', expected: 1 },
                { param: 'asrm_triggered', operator: 'equals', value: 'true', expected: 2 },
                { param: 'asrm_rule_applied', operator: 'equals', value: 'banking_phish_rule', expected: 1 },
                { param: 'asrm_rule_applied', operator: 'equals', value: 'rule_001', expected: 1 },
                { param: 'asrm_rule_applied', operator: 'equals', value: 'Expired Domains', expected: 0 }
            ];
            
            let html = '';
            let passed = 0;
            
            tests.forEach(test => {
                const findings = window.findingsData || [];
                let matches = 0;
                
                findings.forEach(finding => {
                    if (evaluateFilter(finding, test.param, test.operator, test.value)) {
                        matches++;
                    }
                });
                
                const passed_test = matches === test.expected;
                if (passed_test) passed++;
                
                html += `<div class="test-result ${passed_test ? 'pass' : 'fail'}">
                    <strong>${test.param} ${test.operator} "${test.value}"</strong><br>
                    Expected: ${test.expected}, Got: ${matches} ${passed_test ? '✅' : '❌'}
                </div>`;
            });
            
            html += `<div class="test-result info">
                <strong>Summary:</strong> ${passed}/${tests.length} tests passed
            </div>`;
            
            container.innerHTML = html;
        }
        
        // Initialize
        window.onload = function() {
            extractValues();
            displayParameters();
        };
    </script>
</body>
</html>
